# 무한 스크롤 구현 수정 사항 전체 설명

무한 스크롤 기능을 구현하기 위해 **백엔드 (Controller → Service → Repository → Mapper → XML)**와 **프론트엔드 (JSP/JavaScript)**를 모두 수정했습니다.

---

## 📋 **전체 구조**
```
사용자 스크롤 이벤트
    ↓
JavaScript: 현재 페이지 + 1
    ↓
AJAX 요청 (page, size 파라미터)
    ↓
Controller: 요청 받기
    ↓
Service: offset 계산 (page * size)
    ↓
Repository → Mapper
    ↓
MyBatis XML: OFFSET/FETCH로 DB 쿼리
    ↓
결과를 JavaScript로 반환
    ↓
DOM에 상품 카드 추가
```

---

## 🔧 **1. 백엔드 수정 사항**

### **1-1. Controller 계층**
**파일**: `ProductController.java`, `ProductViewController.java`

**변경 내용**: `page`와 `size` 파라미터 추가

```java
// API 컨트롤러
@GetMapping("/category/{categoryId}")
public ResponseEntity<List<ProductByCategoryResponse>> getProductsByCategory(
    @PathVariable Long categoryId,
    @RequestParam(value = "sortBy", required = false, defaultValue = "POPULARITY") String sortBy,
    @RequestParam(value = "page", required = false, defaultValue = "0") int page,      // ✅ 추가
    @RequestParam(value = "size", required = false, defaultValue = "12") int size,     // ✅ 추가
    @CookieValue(value = "Authorization", required = false) String authorizationHeader
)
```

**설명**:
- `page`: 현재 페이지 번호 (0부터 시작)
- `size`: 한 페이지당 보여줄 상품 개수 (기본 12개)
- `defaultValue`로 기본값 설정하여 호환성 유지

---

### **1-2. Service 계층**
**파일**: `ProductService.java`, `ProductServiceImpl.java`

**변경 내용**: offset 계산 로직 추가

```java
@Override
public List<ProductByCategoryResponse> getProductsByCategory(
    Long categoryId, Long userId, String sortBy, int page, int size) {

    // ✅ offset 계산: page * size
    // page=0 → offset=0 (처음 12개)
    // page=1 → offset=12 (13번째~24번째)
    // page=2 → offset=24 (25번째~36번째)
    int offset = page * size;

    List<ProductByCategoryResponse> result = productRepository.getProductsByCategory(
        categoryId, userId, sortBy, offset, size);

    return result;
}
```

**설명**:
- **offset**: 건너뛸 행의 개수
- **limit**: 가져올 행의 개수 (size와 동일)
- 페이지 번호를 offset으로 변환하는 역할

---

### **1-3. Repository 계층**
**파일**: `ProductRepository.java`, `ProductRepositoryImpl.java`

**변경 내용**: offset, limit 파라미터로 변경

```java
// Interface
List<ProductByCategoryResponse> getProductsByCategory(
    Long categoryId, Long userId, String sortBy, int offset, int limit);  // ✅ page/size → offset/limit

// Implementation
@Override
public List<ProductByCategoryResponse> getProductsByCategory(
    Long categoryId, Long userId, String sortBy, int offset, int limit) {
    return productMapper.getProductsByCategory(categoryId, userId, sortBy, offset, limit);
}
```

---

### **1-4. MyBatis Mapper 인터페이스**
**파일**: `ProductMapper.java`

**변경 내용**: @Param 어노테이션 추가

```java
List<ProductByCategoryResponse> getProductsByCategory(
    @Param("categoryId") Long categoryId,
    @Param("userId") Long userId,
    @Param("sortBy") String sortBy,
    @Param("offset") int offset,    // ✅ 추가
    @Param("limit") int limit       // ✅ 추가
);
```

**설명**:
- `@Param`: MyBatis XML에서 `#{offset}`, `#{limit}`로 사용하기 위해 필요

---

### **1-5. MyBatis XML**
**파일**: `ProductMapper.xml`

**변경 내용**: Oracle OFFSET/FETCH 구문 추가

```xml
<select id="getProductsByCategory" resultMap="ProductByCategoryResultMap">
    SELECT
        p.product_id,
        p.product_name,
        p.price,
        p.product_likes,
        p.rating_average,
        p.review_count,
        pi.image_url AS product_image,
        b.brand_name_kr AS brand_name,
        CASE
            WHEN upl.liked = 1 THEN 1
            ELSE 0
        END AS is_liked
    FROM products p
    JOIN brands b ON p.brand_id = b.brand_id
    LEFT JOIN product_images pi ON p.product_id = pi.product_id AND pi.is_main = 1
    LEFT JOIN user_product_like upl ON p.product_id = upl.product_id AND upl.user_id = #{userId}
    WHERE EXISTS (
        SELECT 1 FROM product_categories pc
        WHERE pc.product_id = p.product_id AND pc.category_id = #{categoryId}
    )
    <choose>
        <when test="sortBy == 'PRICE_LOW'">
            ORDER BY p.price ASC
        </when>
        <when test="sortBy == 'PRICE_HIGH'">
            ORDER BY p.price DESC
        </when>
        <otherwise>
            ORDER BY p.product_likes DESC
        </otherwise>
    </choose>
    <!-- ✅ Oracle 페이지네이션 구문 -->
    OFFSET #{offset} ROWS FETCH NEXT #{limit} ROWS ONLY
</select>
```

**설명**:
- `OFFSET #{offset} ROWS`: offset만큼 행을 건너뜀
- `FETCH NEXT #{limit} ROWS ONLY`: limit만큼 행을 가져옴
- Oracle 12c 이상에서 지원하는 표준 SQL 페이지네이션 구문

---

## 🎨 **2. 프론트엔드 수정 사항**

### **2-1. 상태 관리 변수**
```javascript
// 무한 스크롤 기능
let currentPage = 0;        // ✅ 현재 페이지 번호 (0부터 시작)
let isLoading = false;      // ✅ 로딩 중 플래그 (중복 요청 방지)
let hasMoreData = true;     // ✅ 더 가져올 데이터가 있는지 여부
```

---

### **2-2. 상품 로드 함수**
```javascript
function loadMoreProducts() {
    // ✅ 1. 가드 조건: 이미 로딩 중이거나 더 이상 데이터가 없으면 중단
    if (isLoading || !hasMoreData) return;

    // ✅ 2. 로딩 시작
    isLoading = true;
    currentPage++;  // 페이지 증가 (0 → 1 → 2 ...)

    // ✅ 3. URL에서 현재 파라미터 가져오기
    const urlParams = new URLSearchParams(window.location.search);
    const categoryId = window.location.pathname.split('/').pop();  // URL에서 categoryId 추출
    const sortBy = urlParams.get('sortBy') || 'POPULARITY';        // 정렬 방식

    // ✅ 4. AJAX 요청
    $.ajax({
        url: '/api/v1/products/category/' + categoryId,
        method: 'GET',
        data: {
            sortBy: sortBy,
            page: currentPage,  // ✅ 증가된 페이지 번호 전달
            size: 12            // ✅ 한 번에 12개씩
        },
        success: function (products) {
            // ✅ 5. 결과가 없으면 더 이상 데이터가 없다고 표시
            if (products.length === 0) {
                hasMoreData = false;
                return;
            }

            // ✅ 6. DOM에 상품 추가
            const $grid = $('.search-grid');
            products.forEach(function (p) {
                let likesHtml = p.productLikes ?
                    '<span class="likes">♥ ' + p.productLikes.toLocaleString() + '</span>' : '';
                let starsHtml = p.ratingAverage ?
                    '<span class="stars">★' + p.ratingAverage.toFixed(1) + '(' + p.reviewCount + ')</span>' : '';

                // ✅ 문자열 연결로 HTML 생성 (JSP EL 충돌 방지)
                const productHtml =
                    '<a class="product-card" href="/products/' + p.productId + '">' +
                        '<div class="product-image">' +
                            '<img src="' + (p.productImage || '/resources/img/placeholder.png') + '" alt="' + p.productName + '">' +
                            '<i class="fa-heart product-like-icon ' + (p.isLiked ? 'fas filled' : 'far empty') + '" ' +
                                'data-product-id="' + p.productId + '" ' +
                                'onclick="event.preventDefault(); event.stopPropagation(); toggleProductLike(this);"></i>' +
                        '</div>' +
                        '<div class="product-brand">' + p.brandName + '</div>' +
                        '<div class="product-name">' + p.productName + '</div>' +
                        '<div class="product-price">' +
                            '<span class="current-price">' + p.price.toLocaleString() + '원</span>' +
                        '</div>' +
                        '<div class="likes-and-stars">' + likesHtml + starsHtml + '</div>' +
                    '</a>';

                $grid.append(productHtml);  // ✅ 그리드에 추가
            });

            // ✅ 7. 로딩 완료
            isLoading = false;
        },
        error: function (xhr) {
            console.error('상품 로드 실패:', xhr);
            isLoading = false;  // ✅ 에러 시에도 로딩 상태 해제
        }
    });
}
```

---

### **2-3. 스크롤 이벤트 리스너**
```javascript
// ✅ 스크롤 이벤트 리스너
$(window).on('scroll', function () {
    // 현재 스크롤 위치 + 윈도우 높이 >= 문서 전체 높이 - 100px
    // → 바닥에서 100px 위에 도달하면 다음 페이지 로드
    if ($(window).scrollTop() + $(window).height() >= $(document).height() - 100) {
        loadMoreProducts();
    }
});
```

**설명**:
- `$(window).scrollTop()`: 현재 스크롤 위치
- `$(window).height()`: 브라우저 창 높이
- `$(document).height()`: 문서 전체 높이
- `-100`: 바닥에 도달하기 **100px 전**에 미리 로드 (사용자 경험 향상)

---

## ⚠️ **3. 주요 이슈 및 해결**

### **이슈 1: JSP EL 충돌**
**문제**: JavaScript 템플릿 리터럴 `${}` 구문이 JSP EL과 충돌
```javascript
// ❌ 에러 발생
const html = `<span>${p.productLikes}</span>`;
// org.apache.el.parser.ParseException
```

**해결**: 문자열 연결 연산자 `+` 사용
```javascript
// ✅ 정상 동작
const html = '<span>' + p.productLikes + '</span>';
```

---

### **이슈 2: 중복 요청 방지**
**문제**: 스크롤 이벤트가 빠르게 여러 번 발생하여 같은 페이지를 중복 요청

**해결**: `isLoading` 플래그로 요청 중에는 새 요청 차단
```javascript
if (isLoading || !hasMoreData) return;  // ✅ 가드 조건
isLoading = true;  // ✅ 요청 시작
// ... AJAX 요청 ...
isLoading = false; // ✅ 요청 완료
```

---

### **이슈 3: 무한 루프 방지**
**문제**: 데이터가 없는데도 계속 요청을 보냄

**해결**: `hasMoreData` 플래그로 데이터 없으면 요청 중단
```javascript
if (products.length === 0) {
    hasMoreData = false;  // ✅ 더 이상 데이터 없음
    return;
}
```

---

## 📊 **4. 동작 흐름 예시**

### **초기 로드 (page=0)**
1. 사용자가 카테고리 페이지 접속
2. Controller가 `page=0, size=12`로 처음 12개 상품 조회
3. JSP가 12개 상품을 렌더링

### **첫 번째 스크롤 (page=1)**
1. 사용자가 페이지 하단에서 100px 위까지 스크롤
2. JavaScript 이벤트 발생 → `currentPage++` (0 → 1)
3. AJAX로 `page=1, size=12` 요청
4. Service에서 `offset = 1 * 12 = 12` 계산
5. DB에서 `OFFSET 12 ROWS FETCH NEXT 12 ROWS ONLY` 실행
6. 13번째~24번째 상품 반환
7. JavaScript가 DOM에 12개 상품 추가

### **두 번째 스크롤 (page=2)**
1. 다시 하단까지 스크롤
2. `currentPage++` (1 → 2)
3. AJAX로 `page=2, size=12` 요청
4. Service에서 `offset = 2 * 12 = 24` 계산
5. DB에서 25번째~36번째 상품 반환
6. DOM에 추가

### **데이터 종료**
1. AJAX 응답이 빈 배열 `[]` 반환
2. `hasMoreData = false` 설정
3. 이후 스크롤 이벤트 무시

---

## 🎯 **5. 핵심 기술 요약**

| 계층 | 기술 | 역할 |
|------|------|------|
| **Controller** | `@RequestParam` | page, size 파라미터 받기 |
| **Service** | `offset = page * size` | 페이지 번호를 offset으로 변환 |
| **MyBatis** | `@Param` | XML에서 파라미터 바인딩 |
| **SQL** | `OFFSET/FETCH` | Oracle 페이지네이션 |
| **JavaScript** | `AJAX + jQuery` | 비동기 데이터 로드 |
| **이벤트** | `$(window).on('scroll')` | 스크롤 감지 |
| **상태관리** | `currentPage, isLoading, hasMoreData` | 중복 요청 및 무한 루프 방지 |
| **DOM 조작** | `.append()` | 동적으로 상품 카드 추가 |

---

## 📁 **6. 수정된 파일 목록**

### **백엔드 파일**
1. `ProductController.java` - API 엔드포인트에 page, size 파라미터 추가
2. `ProductViewController.java` - 뷰 컨트롤러에 page, size 파라미터 추가
3. `ProductService.java` - 인터페이스에 page, size 파라미터 추가
4. `ProductServiceImpl.java` - offset 계산 로직 구현
5. `ProductRepository.java` - offset, limit 파라미터로 변경
6. `ProductRepositoryImpl.java` - offset, limit 전달
7. `ProductMapper.java` - @Param 어노테이션 추가
8. `ProductMapper.xml` - OFFSET/FETCH 구문 추가

### **프론트엔드 파일**
1. `categoryProductsPage.jsp` - 무한 스크롤 JavaScript 추가
2. `searchProducts.jsp` - 무한 스크롤 JavaScript 추가

---

## 🚀 **7. 테스트 방법**

1. **카테고리 페이지 접속**
   - URL: `http://localhost:8080/products/category/1`
   - 처음 12개 상품이 표시되어야 함

2. **스크롤 테스트**
   - 페이지를 아래로 스크롤
   - 바닥에서 100px 전에 자동으로 다음 12개 상품 로드

3. **네트워크 확인**
   - 개발자 도구 → Network 탭
   - `/api/v1/products/category/1?page=1&size=12` 요청 확인

4. **정렬 테스트**
   - 정렬 버튼 클릭 (인기순, 낮은 가격, 높은 가격)
   - 페이지 리로드 후 다시 무한 스크롤 동작 확인

5. **검색 페이지 테스트**
   - URL: `http://localhost:8080/products?keyword=티셔츠`
   - 동일하게 무한 스크롤 동작 확인

---

## 📝 **8. 향후 개선 사항**

1. **로딩 인디케이터**
   - 데이터 로딩 중 스피너 표시

2. **에러 처리**
   - 네트워크 에러 시 재시도 버튼 표시

3. **성능 최적화**
   - 이미지 Lazy Loading
   - 가상 스크롤 (Virtual Scroll) 적용

4. **사용자 경험 개선**
   - "맨 위로" 버튼 추가
   - 스크롤 위치 저장 (뒤로가기 시)

---

이 문서는 무한 스크롤 구현의 모든 수정 사항과 기술적 세부사항을 포함하고 있습니다.
